/* ===========================================================================
 *
 * Copyright (c) 2020-2021 Disney Streaming Technology LLC. All rights reserved.
 *
 * ==========================================================================*/

/*
shader_compiler.c

cmdlet for compiling glsl shaders to target shader type and #include-able memory regions.
*/

#include "source/adk/cmdlets/shader_compiler/shader_compiler.h"

#include "source/adk/log/log.h"
#include "source/adk/runtime/runtime.h"
#include "source/adk/steamboat/sb_file.h"

#ifdef _WIN32
#include <direct.h>
#else
#include <errno.h>
#include <sys/stat.h>
#include <unistd.h>
#endif

#include <stdio.h>

#ifdef _WIN32
#define strdup(_x) _strdup(_x)
#define getcwd(_x, _size) _getcwd(_x, _size)
#endif

static const char * glslcc_shader_stage_flags[] = {
    [shader_compiler_vert] = " --vert=",
    [shader_compiler_frag] = " --frag=",
};

const char tool_generated_warning[] = "// warning this file is generated by a tool do not modify\n\n";
const char copyright_string[] =
    "/* ===========================================================================\n\
*\n\
* Copyright(c) 2020 Disney Streaming Technology LLC.All rights reserved.\n\
*\n\
* ==========================================================================*/\n\n";

const char * const shader_compiler_stage_suffix[] = {
    [shader_compiler_frag] = ".frag",
    [shader_compiler_vert] = ".vert",
};

const char shader_compiler_raw_path[] = "source/shaders/";
const char shader_compiler_compiled_path[] = "source/shaders/compiled/";
const char shader_compiler_precompile_path[] = "build/glslcc/precompile/";
const char shader_compiler_suffix[] = ".gen.h";

static bool cmdlet_create_directory_path(const char * const input_path) {
    // this function will traverse a re-created filepath to either where you want to store a file.
    // eg.. C:/some_path/with arbitrary_chars/data.dat
    // or the above minus the last file. either or.
    // to do so we peel off characters after each folder level and re-assign them into our buffer
    // thus we don't need more than 1 buffer to work on.. it just needs to be mutable.
    char path[sb_max_path_length];

    char cwd[sb_max_path_length];
    VERIFY(getcwd(cwd, ARRAY_SIZE(cwd)));
    sprintf_s(path, ARRAY_SIZE(path), "%s/%s", cwd, input_path);

    for (char * curr_ptr = path + 1; (curr_ptr = strstr(curr_ptr, "/")) != NULL; ++curr_ptr) {
        // verify for windows like systems that we skip trying to create a drive letter folder.
        // e.g. c:/some_path/other/more
        // we can't make "c:/" so skip it out right.
        // also skip the immediate first slash on linux incase it's causing issues
        const ptrdiff_t head_dist = curr_ptr - path;
        if ((head_dist == 2) && (curr_ptr[-1] == ':')) {
            continue;
        }

        const char curr_char = curr_ptr[1];
        curr_ptr[1] = '\0';

#ifdef _WIN32
        if ((_mkdir(path) != 0) && (errno != EEXIST)) {
            return false;
        }
#else
        if ((mkdir(path, 777) != 0) && (errno != EEXIST)) {
            return false;
        }
#endif
        curr_ptr[1] = curr_char;
    }
    return true;
}

void shader_compiler_raw_file_to_byte_region(
    const char * const raw_bytes_filepath,
    const char * const glsl_filename,
    const char * const directory_name,
    const int region_alignment,
    char * const out_compiled_filename,
    const size_t compiled_filename_len) {
    char genned_filename[shader_compiler_filename_buff_size];
    sprintf_s(genned_filename, ARRAY_SIZE(genned_filename), "%s%s", glsl_filename, shader_compiler_suffix);

    char region_identifier[shader_compiler_filename_buff_size];
    sprintf_s(region_identifier, ARRAY_SIZE(region_identifier), "%s", glsl_filename);

    for (size_t ind = 0; region_identifier[ind] != '\0'; ++ind) {
        if ((region_identifier[ind] < '0') || (region_identifier[ind] > 'z')) {
            region_identifier[ind] = '_';
        }
    }

    sprintf_s(out_compiled_filename, compiled_filename_len, "%s%s/%s", shader_compiler_compiled_path, directory_name, genned_filename);

    FILE * const raw_bytes_file = fopen(raw_bytes_filepath, "rb");
    FILE * const genned_file = fopen(out_compiled_filename, "w");

    VERIFY(raw_bytes_file && genned_file);

    char array_declaration[2 * shader_compiler_filename_buff_size];
    sprintf_s(array_declaration, ARRAY_SIZE(array_declaration), "%s%sstatic const uint8_t ALIGN_N(%s_bytes[], %i) = {", tool_generated_warning, copyright_string, region_identifier, region_alignment);

    fseek(raw_bytes_file, 0, SEEK_END);
    const long raw_bytes_file_len = ftell(raw_bytes_file);
    fseek(raw_bytes_file, 0, SEEK_SET);

    const uint8_t * const raw_bytes = malloc(raw_bytes_file_len);
    VERIFY((long)fread((void *)raw_bytes, 1, raw_bytes_file_len, raw_bytes_file) == raw_bytes_file_len);
    fclose(raw_bytes_file);

    fwrite(array_declaration, 1, strlen(array_declaration), genned_file);

    char byte_buff[10];
    for (long ind = 0; ind < raw_bytes_file_len; ++ind) {
        sprintf_s(byte_buff, ARRAY_SIZE(byte_buff), "%u", (uint32_t)raw_bytes[ind]);
        fwrite(byte_buff, 1, strlen(byte_buff), genned_file);

        if (ind != raw_bytes_file_len - 1) {
            fwrite(", ", 1, 1, genned_file);
        }
    }

    char end_of_file_buff[shader_compiler_filename_buff_size];
    sprintf_s(end_of_file_buff, ARRAY_SIZE(end_of_file_buff), "};\nstatic const const_mem_region_t %s_program = {.ptr = %s_bytes, .size = ARRAY_SIZE(%s_bytes)};\n", region_identifier, region_identifier, region_identifier);

    fwrite(end_of_file_buff, 1, strlen(end_of_file_buff), genned_file);

    fclose(genned_file);
    free((void *)raw_bytes);
}

void shader_compiler_compile_glsl_with_glslcc(
    const char * const glslcc_exe,
    const char * const glsl_filename,
    const char * const shader_stage_filename,
    char * const out_target_output_name,
    const size_t target_output_name_len,
    const char * const output_sub_directory,
    const char * const target_shader_language,
    const shader_compiler_stage_e glslcc_shader_stage) {
    // this is a rough porting of ncp-core(v1)'s glsl -> <target> with vader shader compilation support
    // https://github.bamtech.co/fed-ce-ncp/ncp-core/blob/d69285b84bef206346271487e2d043d4d31e8417/modules/sb/register_types.cpp#L243

    char version_filename[shader_compiler_filename_buff_size];
    sprintf_s(version_filename, ARRAY_SIZE(version_filename), "version_include_file_%s", glsl_filename);

    char include_glsl_shader_path[shader_compiler_filename_buff_size];

    sprintf_s(include_glsl_shader_path, ARRAY_SIZE(include_glsl_shader_path), "%s%s/%s", shader_compiler_precompile_path, output_sub_directory, version_filename);
    cmdlet_create_directory_path(include_glsl_shader_path);

    {
        char version_file_bytes[shader_compiler_filename_buff_size];
        // glslcc doesnt expect old glsl shaders so texture2D needs to be changed.
        sprintf_s(version_file_bytes, ARRAY_SIZE(version_file_bytes), "#version 450\n#define texture2D texture\n#define GLSL_VERSION_450\n%s\n#include \"source/shaders/shader_binding_locations.h\"\n#include \"source/shaders/shader_common_macros.h\"\n#include \"%s\"", shader_stage_macro[glslcc_shader_stage], glsl_filename);

        FILE * const version_file = fopen(include_glsl_shader_path, "w");
        VERIFY(version_file);

        fwrite(version_file_bytes, 1, strlen(version_file_bytes), version_file);
        fclose(version_file);
    }

    char glslcc_shader_target[shader_compiler_filename_buff_size];

    sprintf_s(glslcc_shader_target, ARRAY_SIZE(glslcc_shader_target), "%s%s", glslcc_shader_stage_flags[glslcc_shader_stage], include_glsl_shader_path);

    sprintf_s(out_target_output_name, target_output_name_len, "%s%s/%s", shader_compiler_precompile_path, output_sub_directory, shader_stage_filename);

    char glslcc_target_shader_name[shader_compiler_filename_buff_size];
    sprintf_s(glslcc_target_shader_name, ARRAY_SIZE(glslcc_target_shader_name), "%s%s/%s", shader_compiler_precompile_path, output_sub_directory, glsl_filename);

    char cwd[shader_compiler_filename_buff_size];
    VERIFY(getcwd(cwd, ARRAY_SIZE(cwd)));
    const size_t cwd_len = strlen(cwd);
    for (size_t ind = 0; ind < cwd_len; ++ind) {
        if (cwd[ind] == '\\') {
            cwd[ind] = '/';
        }
    }

    char glslcc_invocation[shader_compiler_filename_buff_size * 4];
    sprintf_s(glslcc_invocation, ARRAY_SIZE(glslcc_invocation), "%s/utilities/glslcc/%s.exe --lang=%s --include-dirs=%s %s --output=%s -b -g", cwd, glslcc_exe, target_shader_language, shader_compiler_raw_path, glslcc_shader_target, glslcc_target_shader_name);

    const int glslcc_err = system(glslcc_invocation);
    sb_unformatted_debug_write_line(glslcc_invocation);
    VERIFY(glslcc_err == 0);
}

static void generate_include_header(const char * const source_glsl_filename, const char * const * const compiled_filenames, const shader_target_t * const targets, const size_t num_compiled_targets) {
    char include_filename[shader_compiler_filename_buff_size];
    sprintf_s(include_filename, ARRAY_SIZE(include_filename), "%s%s%s", shader_compiler_compiled_path, source_glsl_filename, shader_compiler_suffix);

    FILE * const include_file = fopen(include_filename, "w");
    fwrite(tool_generated_warning, 1, ARRAY_SIZE(tool_generated_warning) - 1, include_file);
    fwrite(copyright_string, 1, ARRAY_SIZE(copyright_string) - 1, include_file);

    size_t target_ind = 0;
    char include_block[2 * shader_compiler_filename_buff_size];
    if (num_compiled_targets == 1) {
        sprintf_s(include_block, ARRAY_SIZE(include_block), "#ifdef %s\n#include \"%s\"\n\n", targets[0].macro_guard, compiled_filenames[0]);
    } else {
        for (; target_ind < num_compiled_targets - 1; ++target_ind) {
            if (target_ind == 0) {
                sprintf_s(include_block, ARRAY_SIZE(include_block), "#ifdef %s\n#include \"%s\"\n\n", targets[target_ind].macro_guard, compiled_filenames[target_ind]);
            } else {
                sprintf_s(include_block, ARRAY_SIZE(include_block), "#elif %s\n#include \"%s\"\n\n", targets[target_ind].macro_guard, compiled_filenames[target_ind]);
            }
            fwrite(include_block, 1, strlen(include_block), include_file);
        }
        sprintf_s(include_block, ARRAY_SIZE(include_block), "#else\n\n");
        fwrite(include_block, 1, strlen(include_block), include_file);
    }

    {
        // glsl is the fallback, so we have to special case it (and this means we have to assume that glsl is the last in the supplied array)
        VERIFY(strcmp(targets[target_ind].name, "glsl") == 0);

        sprintf_s(include_block, ARRAY_SIZE(include_block), "#include \"%s\"\n#endif\n", compiled_filenames[target_ind]);
        fwrite(include_block, 1, strlen(include_block), include_file);
    }
    fclose(include_file);
}

int cmdlet_shader_compiler_tool(const int argc, const char * const * const argv) {
    // example cmdlet use
    // --cmdlet shader_compiler canvas.vert,canvas.frag,hello_cube.frag,hello_cube.vert
    // --cmdlet shader_compiler <glsl shader list>.[frag,vert],
    // we expect a comma deliminated list

    const char * const files = getargarg("shader_compiler_tool", argc, argv);
    if (!files || !((strstr(files, shader_compiler_stage_suffix[shader_compiler_vert]) != NULL) || (strstr(files, shader_compiler_stage_suffix[shader_compiler_frag]) != NULL))) {
        debug_write_line(
            "\nshader_compiler cmdlet missing inputs, or unknown file extension. shaders _must_ be located at `source/shaders/`\n"
            "example cmdlet use:\n"
            "--cmdlet shader_compiler canvas.vert,canvas.frag,hello_cube.frag,hello_cube.vert\n"
            "--cmdlet shader_compiler <glsl shader list>.[frag,vert]\n"
            "valid extensions are: [%s] or [%s]\n",
            shader_compiler_stage_suffix[shader_compiler_vert],
            shader_compiler_stage_suffix[shader_compiler_frag]);

        return shader_compiler_no_inputs;
    }

    char * const glsl_files = strdup(files);
    char * curr_file = glsl_files;

    shader_target_t targets[] = {
        {.macro_guard = "_VADER", .alignment = 256, .name = "vader", .shader_compiler_fn = glsl_to_vader2},
        {.macro_guard = "_LEIA", .alignment = 256, .name = "leia", .shader_compiler_fn = glsl_to_leia},
        {.macro_guard = "", .alignment = 0, .name = "glsl", .shader_compiler_fn = glsl_shader_compiler},
    };

    char compiled_target_filenames[ARRAY_SIZE(targets)][shader_compiler_filename_buff_size] = {0};
    const char * compiled_include_filenames[ARRAY_SIZE(targets)] = {0};

    while (*curr_file) {
        char * end_of_curr_file = strchr(curr_file, ',');
        if (end_of_curr_file) {
            *end_of_curr_file = '\0';
        }

        for (int i = 0; i < ARRAY_SIZE(targets); ++i) {
            targets[i].shader_compiler_fn(curr_file, targets[i].name, targets[i].alignment, compiled_target_filenames[i], ARRAY_SIZE(compiled_target_filenames[i]), strstr(curr_file, ".frag") != NULL ? shader_compiler_frag : shader_compiler_vert);

            compiled_include_filenames[i] = compiled_target_filenames[i];
        }

        generate_include_header(curr_file, compiled_include_filenames, targets, ARRAY_SIZE(targets));

        if (end_of_curr_file) {
            curr_file = end_of_curr_file + 1;
        } else {
            break;
        }
    }
    free(glsl_files);

    return shader_compiler_success;
}
